var documenterSearchIndex = {"docs":
[{"location":"#Lexbor.jl","page":"Lexbor.jl","title":"Lexbor.jl","text":"","category":"section"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"This package provides a Julia interface to the lexbor HTML parsing library. Lexbor.jl integrates with AbstractTrees.jl to provide an interface for traversing the HTML tree.","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"Currently the only exposed parts of the library are HTML parsing and DOM querying.","category":"page"},{"location":"#Usage","page":"Lexbor.jl","title":"Usage","text":"","category":"section"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"The package exports it's public interface, but prefer using qualified identifiers rather than using.","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"import Lexbor","category":"page"},{"location":"#Parsing-HTML","page":"Lexbor.jl","title":"Parsing HTML","text":"","category":"section"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"Create a new DOM object using the Document constructor.","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"doc = Lexbor.Document(\"<div class='callout'><a href='#'>Link</a></div>\")","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"Or you can parse a file with Base.open:","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"doc = open(Lexbor.Document, \"file.html\")","category":"page"},{"location":"#Querying-documents","page":"Lexbor.jl","title":"Querying documents","text":"","category":"section"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"Use query to search for nodes within the document that match the provided CSS selector.","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"links = Lexbor.query(doc, \"a\")","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"callouts = Lexbor.query(doc, \"div.callout\")","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"query also supports passing a function as the first argument that will be called on each matching Node that is found. Using this method avoids allocating a vector and iterating over the results twice if they don't need to be stored.","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"Lexbor.query(doc, \"a\") do link\n    @show Lexbor.attributes(link)\nend","category":"page"},{"location":"#Iteration","page":"Lexbor.jl","title":"Iteration","text":"","category":"section"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"You can use any AbstractTrees iterators to traverse the document contents.","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"import AbstractTrees\n\nfor node in AbstractTrees.PreOrderDFS(Lexbor.Node(doc))\n    if Lexbor.is_text(node)\n        @show Lexbor.text(node)\n    end\nend","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"This uses is_text to check whether the current node is a plain text Node and then displays the text content of it using text. Note that newlines and other whitespace is preserved by lexbor's parsing.","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"Other predicates and accessors available are:","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"is_element\nis_comment\ntag\ncomment","category":"page"},{"location":"#Matching-Nodes","page":"Lexbor.jl","title":"Matching Nodes","text":"","category":"section"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"Matcher allows for testing a Node to determine whether it matches the given CSS selector.","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"matcher = Lexbor.Matcher(\"div.callout\")\nfor node in AbstractTrees.PreOrderDFS(Lexbor.Node(doc))\n    if matcher(node)\n        @show node\n    end\nend","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"As with query you can pass a function as the first argument to a Matcher object in which case it will get called when the Node matches and will return nothing instead of true/false.","category":"page"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"for node in AbstractTrees.PreOrderDFS(Lexbor.Node(doc))\n    matcher(node) do matched\n        @show matched\n    end\nend","category":"page"},{"location":"#API","page":"Lexbor.jl","title":"API","text":"","category":"section"},{"location":"","page":"Lexbor.jl","title":"Lexbor.jl","text":"Modules = [Lexbor]","category":"page"},{"location":"#Lexbor.Document","page":"Lexbor.jl","title":"Lexbor.Document","text":"Document(html_str)\nopen(Document, html_file_path)\n\nParse HTML into an in-memory tree representing the DOM. To parse an HTML file use Base.open.\n\n\n\n\n\n","category":"type"},{"location":"#Lexbor.Matcher","page":"Lexbor.jl","title":"Lexbor.Matcher","text":"Matcher(selector; first = false)\n\nCreate a new Matcher object that can be used to test whether a Node matches the selector or not. Matcher objects are callable and can be used as follows:\n\nfunction find_first_node(root, selector)\n    # Create the `Matcher` object once, then reuse in the loop.\n    matcher = Matcher(selector)\n    for node in AbstractTrees.PreOrderDFS(root)\n        if matcher(node)\n            return node\n        end\n    end\n    return nothing\nend\n\nThe matcher object has two callable methods. The first, shown above, returns true or false depending on whether the selector matches. The other method takes a first argument function ::Node -> Nothing that is called when the selector matches.\n\nThe keyword argument first::Bool has the same behaviour as the first keyword provided by query. See that function's documentation for details.\n\n\n\n\n\n","category":"type"},{"location":"#Lexbor.Node","page":"Lexbor.jl","title":"Lexbor.Node","text":"Node(document::Document)\n\nAn iterable object representing a particular node within an HTML Document.\n\n\n\n\n\n","category":"type"},{"location":"#Lexbor.Tree","page":"Lexbor.jl","title":"Lexbor.Tree","text":"Tree(document)\nTree(node)\n\nA display type to help visualize DOM structure.\n\n\n\n\n\n","category":"type"},{"location":"#Lexbor.attributes-Tuple{Node}","page":"Lexbor.jl","title":"Lexbor.attributes","text":"attributes(node::Node) -> Dict{String,Union{String,Nothing}} | Nothing\n\nReturn a Dict of all the attributes of a node, or nothing when it is not a valid element node.\n\n\n\n\n\n","category":"method"},{"location":"#Lexbor.comment-Tuple{Node}","page":"Lexbor.jl","title":"Lexbor.comment","text":"comment(node) -> String | nothing\n\nReturn the comment content of a node, or nothing when the node is not a valid comment node.\n\n\n\n\n\n","category":"method"},{"location":"#Lexbor.is_comment-Tuple{Node}","page":"Lexbor.jl","title":"Lexbor.is_comment","text":"is_comment(node::Node) -> Bool\n\nIs node a comment Node? E.g. <!-- ... --> syntax.\n\nUse comment to access the String contents of the comment.\n\n\n\n\n\n","category":"method"},{"location":"#Lexbor.is_element-Tuple{Node}","page":"Lexbor.jl","title":"Lexbor.is_element","text":"is_element(node::Node) -> Bool\n\nIs the node an HTML element Node? E.g. a <a>, <div>, etc.\n\nUse tag to access the name of the element as a Symbol and use attributes to access the element attributes.\n\n\n\n\n\n","category":"method"},{"location":"#Lexbor.is_text-Tuple{Node}","page":"Lexbor.jl","title":"Lexbor.is_text","text":"is_text(node::Node) -> Bool\n\nIs the node a plain text string?\n\nUse text to access the String contents of the node.\n\n\n\n\n\n","category":"method"},{"location":"#Lexbor.query","page":"Lexbor.jl","title":"Lexbor.query","text":"query(document | node, selector; first = false, root = false) -> Node[]\nquery(f, document | node, selector; first = false, root = false) -> nothing\n\nQuery the document or node for the given CSS selector. When f is provided then call f on each match that is found and return nothing from query. When no f is provided then just return a Vector{Node} containing all matches.\n\nThe first::Bool keyword controls whether to only match the first of a selector list. To quote the upstream documentation:\n\nStop searching after the first match with any of the selectors in the list.By default, the callback will be triggered for each selector list. That is, if your node matches different selector lists, it will be returned multiple times in the callback.For example:HTML: <div id=\"ok\"><span>test</span></div>\nSelectors: div, div[id=\"ok\"], div:has(:not(a))The default behavior will cause three callbacks with the same node (div). Because it will be found by every selector in the list.This option allows you to end the element check after the first match on any of the selectors. That is, the callback will be called only once for example above. This way we get rid of duplicates in the search.\n\nThe root::Bool keyword controls whether to include the root node in the search. To quote the upstream documentation:\n\nIncludes the passed (root) node in the search.By default, the root node does not participate in selector searches, only its children.This behavior is logical, if you have found a node and then you want to search for other nodes in it, you don't need to check it again.But there are cases when it is necessary for root node to participate in the search.  That's what this option is for.\n\n\n\n\n\n","category":"function"},{"location":"#Lexbor.tag-Tuple{Node}","page":"Lexbor.jl","title":"Lexbor.tag","text":"tag(node) -> Symbol | Nothing\n\nReturn the element tag name, or nothing when it is not an element.\n\n\n\n\n\n","category":"method"},{"location":"#Lexbor.text-Tuple{Node}","page":"Lexbor.jl","title":"Lexbor.text","text":"text(node) -> String | Nothing\n\nReturn the text content of a node, or nothing when the node is not a valid text node.\n\n\n\n\n\n","category":"method"}]
}
