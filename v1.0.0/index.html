<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lexbor.jl · Lexbor</title><meta name="title" content="Lexbor.jl · Lexbor"/><meta property="og:title" content="Lexbor.jl · Lexbor"/><meta property="twitter:title" content="Lexbor.jl · Lexbor"/><meta name="description" content="Documentation for Lexbor."/><meta property="og:description" content="Documentation for Lexbor."/><meta property="twitter:description" content="Documentation for Lexbor."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Lexbor</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Lexbor.jl</a><ul class="internal"><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Lexbor.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lexbor.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MichaelHatherly/Lexbor.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MichaelHatherly/Lexbor.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lexbor.jl"><a class="docs-heading-anchor" href="#Lexbor.jl">Lexbor.jl</a><a id="Lexbor.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Lexbor.jl" title="Permalink"></a></h1><p>This package provides a Julia interface to the <a href="https://github.com/lexbor/lexbor">lexbor</a> HTML parsing library. <code>Lexbor.jl</code> integrates with <code>AbstractTrees.jl</code> to provide an interface for traversing the HTML tree.</p><p>Currently the only exposed parts of the library are HTML parsing and DOM querying.</p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>The package <code>export</code>s it&#39;s public interface, but prefer using qualified identifiers rather than <code>using</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import Lexbor</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h3 id="Parsing-HTML"><a class="docs-heading-anchor" href="#Parsing-HTML">Parsing HTML</a><a id="Parsing-HTML-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing-HTML" title="Permalink"></a></h3><p>Create a new DOM object using the <code>Document</code> constructor.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; doc = Lexbor.Document(&quot;&lt;div class=&#39;callout&#39;&gt;&lt;a href=&#39;#&#39;&gt;Link&lt;/a&gt;&lt;/div&gt;&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Document(source = nothing)</code></pre><p>Or you can parse a file with <code>Base.open</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; doc = open(Lexbor.Document, &quot;file.html&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Document(source = &quot;file.html&quot;)</code></pre><h3 id="Querying-documents"><a class="docs-heading-anchor" href="#Querying-documents">Querying documents</a><a id="Querying-documents-1"></a><a class="docs-heading-anchor-permalink" href="#Querying-documents" title="Permalink"></a></h3><p>Use <code>query</code> to search for nodes within the document that match the provided CSS selector.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; links = Lexbor.query(doc, &quot;a&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Node}:
 &lt;a&gt;</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; callouts = Lexbor.query(doc, &quot;div.callout&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Node}:
 &lt;div&gt;</code></pre><p><a href="#Lexbor.query"><code>query</code></a> also supports passing a function as the first argument that will be called on each matching <a href="#Lexbor.Node"><code>Node</code></a> that is found. Using this method avoids allocating a vector and iterating over the results twice if they don&#39;t need to be stored.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Lexbor.query(doc, &quot;a&quot;) do link
           @show Lexbor.attributes(link)
       end</code><code class="nohighlight hljs ansi" style="display:block;">Lexbor.attributes(link) = Dict{String, Union{Nothing, String}}(&quot;href&quot; =&gt; &quot;#&quot;)</code></pre><h3 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h3><p>You can use any <code>AbstractTrees</code> iterators to traverse the document contents.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import AbstractTrees</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for node in AbstractTrees.PreOrderDFS(Lexbor.Node(doc))
           if Lexbor.is_text(node)
               @show Lexbor.text(node)
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">Lexbor.text(node) = &quot;\n    &quot;
Lexbor.text(node) = &quot;Link&quot;
Lexbor.text(node) = &quot;\n&quot;
Lexbor.text(node) = &quot;\n&quot;</code></pre><p>This uses <a href="#Lexbor.is_text-Tuple{Node}"><code>is_text</code></a> to check whether the current <code>node</code> is a plain text <a href="#Lexbor.Node"><code>Node</code></a> and then displays the text content of it using <a href="#Lexbor.text-Tuple{Node}"><code>text</code></a>. Note that newlines and other whitespace is preserved by lexbor&#39;s parsing.</p><p>Other predicates and accessors available are:</p><ul><li><a href="#Lexbor.is_element-Tuple{Node}"><code>is_element</code></a></li><li><a href="#Lexbor.is_comment-Tuple{Node}"><code>is_comment</code></a></li><li><a href="#Lexbor.tag-Tuple{Node}"><code>tag</code></a></li><li><a href="#Lexbor.comment-Tuple{Node}"><code>comment</code></a></li></ul><h3 id="Matching-Nodes"><a class="docs-heading-anchor" href="#Matching-Nodes">Matching <code>Node</code>s</a><a id="Matching-Nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Matching-Nodes" title="Permalink"></a></h3><p><a href="#Lexbor.Matcher"><code>Matcher</code></a> allows for testing a <a href="#Lexbor.Node"><code>Node</code></a> to determine whether it matches the given CSS selector.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; matcher = Lexbor.Matcher(&quot;div.callout&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Matcher(&quot;div.callout&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for node in AbstractTrees.PreOrderDFS(Lexbor.Node(doc))
           if matcher(node)
               @show node
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">node = &lt;div&gt;</code></pre><p>As with <a href="#Lexbor.query"><code>query</code></a> you can pass a function as the first argument to a <a href="#Lexbor.Matcher"><code>Matcher</code></a> object in which case it will get called when the <a href="#Lexbor.Node"><code>Node</code></a> matches and will return <code>nothing</code> instead of <code>true</code>/<code>false</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; for node in AbstractTrees.PreOrderDFS(Lexbor.Node(doc))
           matcher(node) do matched
               @show matched
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">matched = &lt;div&gt;</code></pre><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Lexbor.Document" href="#Lexbor.Document"><code>Lexbor.Document</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Document(html_str)
open(Document, html_file_path)</code></pre><p>Parse HTML into an in-memory tree representing the DOM. To parse an HTML file use <code>Base.open</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MichaelHatherly/Lexbor.jl/blob/5a03a44c8fccf460ad778a3fea77be12b26f7fc2/src/Lexbor.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Lexbor.Matcher" href="#Lexbor.Matcher"><code>Lexbor.Matcher</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Matcher(selector; first = false)</code></pre><p>Create a new <code>Matcher</code> object that can be used to test whether a <code>Node</code> matches the <code>selector</code> or not. <code>Matcher</code> objects are callable and can be used as follows:</p><pre><code class="language-julia hljs">function find_first_node(root, selector)
    # Create the `Matcher` object once, then reuse in the loop.
    matcher = Matcher(selector)
    for node in AbstractTrees.PreOrderDFS(root)
        if matcher(node)
            return node
        end
    end
    return nothing
end</code></pre><p>The <code>matcher</code> object has two callable methods. The first, shown above, returns <code>true</code> or <code>false</code> depending on whether the selector matches. The other method takes a first argument function <code>::Node -&gt; Nothing</code> that is called when the selector matches.</p><p>The keyword argument <code>first::Bool</code> has the same behaviour as the <code>first</code> keyword provided by <code>query</code>. See that function&#39;s documentation for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MichaelHatherly/Lexbor.jl/blob/5a03a44c8fccf460ad778a3fea77be12b26f7fc2/src/Lexbor.jl#L362-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Lexbor.Node" href="#Lexbor.Node"><code>Lexbor.Node</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Node(document::Document)</code></pre><p>An iterable object representing a particular node within an HTML <code>Document</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MichaelHatherly/Lexbor.jl/blob/5a03a44c8fccf460ad778a3fea77be12b26f7fc2/src/Lexbor.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Lexbor.Tree" href="#Lexbor.Tree"><code>Lexbor.Tree</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tree(document)
Tree(node)</code></pre><p>A display type to help visualize DOM structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MichaelHatherly/Lexbor.jl/blob/5a03a44c8fccf460ad778a3fea77be12b26f7fc2/src/Lexbor.jl#L113-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Lexbor.attributes-Tuple{Node}" href="#Lexbor.attributes-Tuple{Node}"><code>Lexbor.attributes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">attributes(node::Node) -&gt; Dict{String,Union{String,Nothing}} | Nothing</code></pre><p>Return a <code>Dict</code> of all the attributes of a node, or <code>nothing</code> when it is not a valid element node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MichaelHatherly/Lexbor.jl/blob/5a03a44c8fccf460ad778a3fea77be12b26f7fc2/src/Lexbor.jl#L199-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Lexbor.comment-Tuple{Node}" href="#Lexbor.comment-Tuple{Node}"><code>Lexbor.comment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comment(node) -&gt; String | nothing</code></pre><p>Return the comment content of a node, or <code>nothing</code> when the node is not a valid comment node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MichaelHatherly/Lexbor.jl/blob/5a03a44c8fccf460ad778a3fea77be12b26f7fc2/src/Lexbor.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Lexbor.is_comment-Tuple{Node}" href="#Lexbor.is_comment-Tuple{Node}"><code>Lexbor.is_comment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_comment(node::Node) -&gt; Bool</code></pre><p>Is <code>node</code> a comment <code>Node</code>? E.g. <code>&lt;!-- ... --&gt;</code> syntax.</p><p>Use <a href="#Lexbor.comment-Tuple{Node}"><code>comment</code></a> to access the <code>String</code> contents of the comment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MichaelHatherly/Lexbor.jl/blob/5a03a44c8fccf460ad778a3fea77be12b26f7fc2/src/Lexbor.jl#L130-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Lexbor.is_element-Tuple{Node}" href="#Lexbor.is_element-Tuple{Node}"><code>Lexbor.is_element</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_element(node::Node) -&gt; Bool</code></pre><p>Is the <code>node</code> an HTML element <code>Node</code>? E.g. a <code>&lt;a&gt;</code>, <code>&lt;div&gt;</code>, etc.</p><p>Use <a href="#Lexbor.tag-Tuple{Node}"><code>tag</code></a> to access the name of the element as a <code>Symbol</code> and use <a href="#Lexbor.attributes-Tuple{Node}"><code>attributes</code></a> to access the element attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MichaelHatherly/Lexbor.jl/blob/5a03a44c8fccf460ad778a3fea77be12b26f7fc2/src/Lexbor.jl#L140-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Lexbor.is_text-Tuple{Node}" href="#Lexbor.is_text-Tuple{Node}"><code>Lexbor.is_text</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_text(node::Node) -&gt; Bool</code></pre><p>Is the <code>node</code> a plain text string?</p><p>Use <a href="#Lexbor.text-Tuple{Node}"><code>text</code></a> to access the <code>String</code> contents of the <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MichaelHatherly/Lexbor.jl/blob/5a03a44c8fccf460ad778a3fea77be12b26f7fc2/src/Lexbor.jl#L150-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Lexbor.query" href="#Lexbor.query"><code>Lexbor.query</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">query(document | node, selector; first = false, root = false) -&gt; Node[]
query(f, document | node, selector; first = false, root = false) -&gt; nothing</code></pre><p>Query the <code>document</code> or <code>node</code> for the given CSS <code>selector</code>. When <code>f</code> is provided then call <code>f</code> on each match that is found and return <code>nothing</code> from <code>query</code>. When no <code>f</code> is provided then just return a <code>Vector{Node}</code> containing all matches.</p><p>The <code>first::Bool</code> keyword controls whether to only match the first of a selector list. To quote the upstream documentation:</p><blockquote><p>Stop searching after the first match with any of the selectors in the list.</p><p>By default, the callback will be triggered for each selector list. That is, if your node matches different selector lists, it will be returned multiple times in the callback.</p><p>For example:</p><pre><code class="language-plaintext hljs">HTML: &lt;div id=&quot;ok&quot;&gt;&lt;span&gt;test&lt;/span&gt;&lt;/div&gt;
Selectors: div, div[id=&quot;ok&quot;], div:has(:not(a))</code></pre><p>The default behavior will cause three callbacks with the same node (div). Because it will be found by every selector in the list.</p><p>This option allows you to end the element check after the first match on any of the selectors. That is, the callback will be called only once for example above. This way we get rid of duplicates in the search.</p></blockquote><p>The <code>root::Bool</code> keyword controls whether to include the root node in the search. To quote the upstream documentation:</p><blockquote><p>Includes the passed (root) node in the search.</p><p>By default, the root node does not participate in selector searches, only its children.</p><p>This behavior is logical, if you have found a node and then you want to search for other nodes in it, you don&#39;t need to check it again.</p><p>But there are cases when it is necessary for root node to participate in the search.  That&#39;s what this option is for.</p></blockquote></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MichaelHatherly/Lexbor.jl/blob/5a03a44c8fccf460ad778a3fea77be12b26f7fc2/src/Lexbor.jl#L239-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Lexbor.tag-Tuple{Node}" href="#Lexbor.tag-Tuple{Node}"><code>Lexbor.tag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tag(node) -&gt; Symbol | Nothing</code></pre><p>Return the element tag name, or <code>nothing</code> when it is not an element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MichaelHatherly/Lexbor.jl/blob/5a03a44c8fccf460ad778a3fea77be12b26f7fc2/src/Lexbor.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Lexbor.text-Tuple{Node}" href="#Lexbor.text-Tuple{Node}"><code>Lexbor.text</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">text(node) -&gt; String | Nothing</code></pre><p>Return the text content of a node, or <code>nothing</code> when the node is not a valid text node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MichaelHatherly/Lexbor.jl/blob/5a03a44c8fccf460ad778a3fea77be12b26f7fc2/src/Lexbor.jl#L167-L172">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 7 January 2025 11:10">Tuesday 7 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
